/*
 * generated by Xtext
 */
package de.beyondjava.xtext.jsf.generator

import de.beyondjava.xtext.jsf.componentLanguage.Attribute
import de.beyondjava.xtext.jsf.componentLanguage.Component
import de.beyondjava.xtext.jsf.formatting.JavaFormatter
import org.eclipse.core.resources.ResourcesPlugin
import org.eclipse.core.runtime.Path
import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.IFileSystemAccess
import org.eclipse.xtext.generator.IGenerator

/**
 * Generates code from your model files on save.
 *
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class RendererGenerator implements IGenerator {

	override void doGenerate(Resource resource, IFileSystemAccess fsa) {
		for (e : resource.allContents.toIterable.filter(Component)) {
		val platformString = resource.URI.toPlatformString(true);
		var content = e.compile();
		val myFile = ResourcesPlugin.getWorkspace().getRoot().getFile(new Path(platformString));
		val project = myFile.getProject();
		var formatted = JavaFormatter.format(content.toString, project);
		fsa.generateFile("net/bootsfaces/component/"+e.name.toFirstLower + "/" + e.name.toFirstUpper + "Renderer.java", formatted)
		}
	}

	def compile(Component e) '''
		/**
		 *  Copyright 2014-15 by Riccardo Massera (TheCoder4.Eu) and Stephan Rauh (http://www.beyondjava.net).
		 *
		 *  This file is part of BootsFaces.
		 *
		 *  BootsFaces is free software: you can redistribute it and/or modify
		 *  it under the terms of the GNU Lesser General Public License as published by
		 *  the Free Software Foundation, either version 3 of the License, or
		 *  (at your option) any later version.
		 *
		 *  BootsFaces is distributed in the hope that it will be useful,
		 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
		 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
		 *  GNU Lesser General Public License for more details.
		 *
		 *  You should have received a copy of the GNU Lesser General Public License
		 *  along with BootsFaces. If not, see <http://www.gnu.org/licenses/>.
		 */

		package net.bootsfaces.component.«e.name.toFirstLower»;

		import javax.faces.component.*;
		import java.io.IOException;
		import java.util.Map;

		import javax.faces.context.FacesContext;
		import javax.faces.context.ResponseWriter;
		import javax.faces.render.FacesRenderer;

		import net.bootsfaces.render.CoreRenderer;
		import net.bootsfaces.render.Tooltip;


		/** This class generates the HTML code of &lt;b:«e.name» /&gt;. */
		@FacesRenderer(componentFamily = "net.bootsfaces.component", rendererType = "net.bootsfaces.component.«e.name.toFirstLower».«e.widgetClass»")
		public class «e.widgetClass»Renderer extends CoreRenderer {
			«IF e.processesInput!=null»
			«generateDecodeMethod(e)»
			«ENDIF»

			«generateEncodeBeginMethod(e)»

			«IF e.hasChildren!=null»
				«generateEncodeEndMethod(e)»
			«ENDIF»

		}
			'''

	def generateDecodeMethod(Component e)
		'''
			/**
			 * This methods receives and processes input made by the user. More specifically, it ckecks whether the
			 * user has interacted with the current b:«e.widget». The default implementation simply stores
			 * the input value in the list of submitted values. If the validation checks are passed,
			 * the values in the <code>submittedValues</code> list are store in the backend bean.
			 * @param context the FacesContext.
			 * @param component the current b:«e.widget».
			 */
			@Override
			public void decode(FacesContext context, UIComponent component) {
			    «e.widgetClass» «e.widget» = («e.widgetClass») component;

				«e.returnIfDisabled»

			    decodeBehaviors(context, «e.widget»);

			    String clientId = «e.widget».getClientId(context);
			    String submittedValue = (String) context.getExternalContext().getRequestParameterMap().get(clientId);

			    if (submittedValue != null) {
			    	«e.widget».setSubmittedValue(submittedValue);
			    }
			}
		'''

	def getReturnIfDisabled(Component component) {
		if (component.attributes.exists[a | "disabled" == a.name])
		{
			return '''
				if («component.widget».isDisabled() || «component.widget».isReadonly()) {
				    return;
				}
			'''
		}
		""
	}


	def generateEncodeBeginMethod(Component e)
		'''
			/**
			 * This methods generates the HTML code of the current b:«e.widget».
			«IF e.hasChildren!=null»
			 * <code>encodeBegin</code> generates the start of the component. After the, the JSF framework calls <code>encodeChildren()</code>
			 * to generate the HTML code between the beginning and the end of the component. For instance, in the case of a panel component
			 * the content of the panel is generated by <code>encodeChildren()</code>. After that, <code>encodeEnd()</code> is called
			 * to generate the rest of the HTML code.
			 «ENDIF»
			 * @param context the FacesContext.
			 * @param component the current b:«e.widget».
			 * @throws IOException thrown if something goes wrong when writing the HTML code.
			 */
			@Override
			public void encodeBegin(FacesContext context, UIComponent component) throws IOException {
			    if (!component.isRendered()) {
			        return;
			    }
				«e.widgetClass» «e.widget» = («e.widgetClass») component;
				ResponseWriter rw = context.getResponseWriter();
				String clientId = «e.widget».getClientId();

				// put custom code here
				// Simple demo widget that simply renders every attribute value
				rw.startElement("«e.widget»", «e.widget»);
				«IF e.hasTooltip!=null»
					Tooltip.generateTooltip(context, «e.widget», rw);
				«ENDIF»

			    «FOR f : e.attributes»
			        rw.writeAttribute("«f.name»", «parameterAsString(e, f)», "«f.name»");
			    «ENDFOR»
				rw.writeText("Dummy content of b:«e.widget»", null);
				«IF e.hasChildren==null»
				    rw.endElement("«e.widget»");
				    «IF e.hasTooltip!=null»
				    Tooltip.activateTooltips(context, «e.widget»);
				    «ENDIF»
				«ENDIF»

			}
		'''

	def generateEncodeEndMethod(Component e)
		'''
			/**
			 * This methods generates the HTML code of the current b:«e.widget».
			«IF e.hasChildren!=null»
			 * <code>encodeBegin</code> generates the start of the component. After the, the JSF framework calls <code>encodeChildren()</code>
			 * to generate the HTML code between the beginning and the end of the component. For instance, in the case of a panel component
			 * the content of the panel is generated by <code>encodeChildren()</code>. After that, <code>encodeEnd()</code> is called
			 * to generate the rest of the HTML code.
			 «ENDIF»
			 * @param context the FacesContext.
			 * @param component the current b:«e.widget».
			 * @throws IOException thrown if something goes wrong when writing the HTML code.
			 */
			@Override
			public void encodeEnd(FacesContext context, UIComponent component) throws IOException {
			    if (!component.isRendered()) {
			        return;
			    }
				«e.widgetClass» «e.widget» = («e.widgetClass») component;
				ResponseWriter rw = context.getResponseWriter();
				String clientId = «e.widget».getClientId();
				rw.endElement("«e.widget»");
				«IF e.hasTooltip != null»
					Tooltip.activateTooltips(fc, c);
			    «ENDIF»

			}
		'''

		/** Boolean parameters are rendered slightly unexpected by JSF, so it's better to pass the desired String for the sake of clarity */
		def parameterAsString(Component e, Attribute f) {
			if ("Boolean"==f.type)
				'''String.valueOf(«e.widget»«getGetter(f)»)'''
			else
				'''«e.widget»«getGetter(f)»'''
		}



		def getGetter(Attribute f)
		{
			if ("Boolean".equals(f.type)) {
				'''.is«f.name.toFirstUpper»()'''
			}
			else {
				'''.get«f.name.toFirstUpper»()'''
			}
		}


	def widgetClass(Component c) {
		'''«c.name.toFirstUpper»'''
	}

	def widget(Component c) {
		'''«c.name.toFirstLower»'''
	}
}
